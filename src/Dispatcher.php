<?php

namespace Kraken\Redis;

use Kraken\Loop\Loop;
use Kraken\Loop\LoopInterface;
use Kraken\Promise\Deferred;
use Kraken\Ipc\Socket\Socket;
use Kraken\Redis\Protocol\Resp;
use Kraken\Event\AsyncEventEmitter;
use Clue\Redis\Protocol\Model\ErrorReply;
use Clue\Redis\Protocol\Model\ModelInterface;
use RuntimeException;
use UnderflowException;
use Clue\Redis\Protocol\Parser\ParserException;

class Dispatcher extends AsyncEventEmitter
{

    /**
     * @var Socket
     */
    private $stream;
    /**
     * @var Resp
     */
    private $protocol;

    protected $requests;

    private $ending;

    private $closed;

    public function __construct(LoopInterface $loop)
    {
        parent::__construct($loop); // TODO: Change the autogenerated stub
        $this->requests = [];
        $this->ending = false;
        $this->closed = false;
        $this->protocol = new Resp();
        $this->on('connect', [$this, 'handleConnect']);
        $this->on('response',[$this, 'handleResponse']);
        $this->on('disconnect',[$this, 'handleDisconnect']);
        $this->on('close', [$this, 'handleClose']);
    }

    public function appendRequest($request)
    {
        $this->requests[] = $request;
    }

    public function finishRequest()
    {
        return array_shift($this->requests);
    }

    public function needStop()
    {
        return count($this->requests) <= 0 ? true : false;
    }

    public function run($uri)
    {
        if ($this->stream !== null) {
            return;
        }

        try {
            $this->stream = new Socket($uri, $this->getLoop());
        } catch (\Exception $e) {
            $this->stop();
        }

        if ($this->stream->isOpen()) {
            $this->emit('connect', [$this]);
        }

        $this->getLoop()->start();
    }

    public function stop()
    {
        $this->getLoop()->stop();
    }

    /**
     * @internal
     */
    public function handleConnect()
    {
        $protocol = $this->protocol;
        $that = $this;

        $this->stream->on('data', function($_, $chunk) use ($protocol, $that) {
            try {
                $models = $protocol->parseResponse($chunk);
            } catch (ParserException $error) {
                $this->ending = true;
                $that->emit('error', [$error]);
                $that->emit('close');

                return;
            }

            foreach ($models as $data) {
                try {
                    $this->emit('response', [$data]);
                } catch (UnderflowException $error) {
                    $that->emit('error', [$error]);
                }
            }
        });

        $this->emit('request');
    }

    /**
     * @internal
     * @param $payload
     */
    public function handleRequest($payload)
    {
        $this->stream->write($payload);
    }

    /**
     * @internal
     */
    public function handleResponse(ModelInterface $message)
    {
        if (!$this->requests) {
            throw new UnderflowException('Unexpected reply received, no matching request found');
        }
        /* @var Deferred $request */
        $request = $this->finishRequest();

        if ($message instanceof ErrorReply) {
            $request->reject($message);
        } else {
            $request->resolve($message->getValueNative());
        }

        if ($this->needStop()) {
            $this->emit('disconnect');
        }
    }

    /**
     * @internal
     */
    public function handleDisconnect()
    {
        $this->ending = true;
        $this->stream->close();
        // reject all remaining requests in the queue
        while($this->requests) {
            $request = array_shift($this->requests);
            /* @var $request Deferred */
            $request->reject(new RuntimeException('Connection closing'));
        }
        $this->emit('close');
    }

    /**
     * @internal
     */
    public function handleClose()
    {
        if ($this->closed) {
            return;
        }
        $this->removeListeners('connect');
        $this->removeListeners('response');
        $this->removeListeners('disconnect');
        $this->removeListeners('close');
        $this->removeListeners('error');
        $this->getLoop()->stop();
        $this->closed = true;
    }
}